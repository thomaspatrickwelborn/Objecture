var e={default:(e,t)=>void 0===t?e:e[t],get:(e,t)=>void 0===t?e:e.get(t)};function t(e,t=":scope"){if(Array.isArray(e)||void 0===e)return e;const n=[];for(const[r,s]of Object.entries(e)){const e=r.trim().split(" ");let i,o,a;1===e.length?(i=t,o=e[0]):e.length>1&&(i=e[0],o=e[1]),Array.isArray(s)?(a=s[0],s[1]):a=s;const c={type:o,path:i,listener:a,enable:!1};n.push(c)}return n}const n=e=>Object.prototype.toString.call(e).slice(8,-1).toLowerCase();function r(e){let t;const r=n(e);return"object"===r?t={}:"array"===r?t=[]:"string"===r?"object"===e?t={}:"array"===e&&(t=[]):t=void 0,t}const s={string:String,number:Number,boolean:Boolean,undefined:void 0,null:null},i=Object.keys(s),o=Object.values(s),a={object:Object,array:Array},c=Object.keys(a),l=Object.values(a),p=Object.assign({},s,a),u=Object.keys(p),d=Object.values(p),h=[s.String,s.Number,s.Boolean,a.Object,a.Array];var f=Object.freeze({__proto__:null,ObjectKeys:c,ObjectValues:l,Objects:a,PrimitiveKeys:i,PrimitiveValues:o,Primitives:s,TypeKeys:u,TypeMethods:h,TypeValues:d,Types:p}),v={quotationEscape:/\.(?=(?:[^"]*"[^"]*")*[^"]*$)/};function g(e){return e.split(new RegExp(v.quotationEscape))}function y(e){const t=g(e);return t.pop(),t}function b(e){return g(e).pop()}function j(e){return g(e).shift()}function m(e){return Number(j(e))?"array":"object"}function O(e){return{subpaths:g(e),keypaths:y(e),key:b(e),root:j(e),typeofRoot:m(e)}}function P(e,t){const n=e.split(new RegExp(v.quotationEscape)),r=n.pop();let s=t;for(const e of n)s=s[e];return s[r]}function E(e,t){const{keypaths:n,key:s,typeofRoot:i}=O(e),o=r(i);let a=o;for(const e of n)Number(e)?a[e]=[]:a[e]={},a=a[e];return a[s]=t,o}const x={depth:0,maxDepth:10,accessors:[e.default]};function w(e,t){const n=[],r=Object.assign({},x,t);if(r.depth++,r.depth>r.maxDepth)return n;for(const t of r.accessors){const s=t(e);if(s)for(const[e,t]of Object.entries(s))if(n.push(e),"object"==typeof t&&null!==t&&t!==s){const s=w(t,r);for(const t of s){let r;r="object"==typeof t?[e,...t].join("."):[e,t].join("."),n.push(r)}}}return n}function k(e,...t){if(!e)return e;for(const r of t)if(r)for(const[t,s]of Object.entries(r)){const r=n(e[t]),i=n(s);e[t]="object"===r&&"object"===i?k(e[t],s):s}return e}var A=Object.freeze({__proto__:null,accessors:e,expandEvents:t,expandTree:function(e,t){const n=typeof e,r=typeof t;if(!["string","function"].includes(r))return;let s;if(e&&"object"===n)for(const[n,i]of Object.entries(e))"string"===r?s=E(t,i):"function"===r&&(s=t(i));else"string"===r?s=E(t,e):"function"===r&&(s=t(e));return s},impandEvents:function(e){if(!Array.isArray(e))return e;const t={};for(const n of e){const{path:e,type:r,listener:s,options:i}=n,o=`${$path} ${$type}`;t[o]=void 0!==i?[s,i]:s}return t},impandTree:function(e,t){const n=typeof t,s=typeof e;if(!["string","function"].includes(n)||s&&"object"!==s)return;let i=r(e);if("object"===s)for(const[r,s]of Object.entries(e))"string"===n?i[r]=P(t,s):"function"===n&&(i=t(s));return i},isPropertyDefinition:function(e){return!!(Object.getOwnPropertyDescriptor(e,"type")&&(d.includes(e.type)||u.includes(e.type))||"object"==typeof e.type&&Object.getOwnPropertyDescriptor(e.type,"value")&&(d.includes(e.type.value)||u.includes(e.type.value)))},propertyDirectory:w,recursiveAssign:k,recursiveAssignConcat:function e(t,...r){if(!t)return t;for(const s of r)if(s)for(const[r,i]of Object.entries(s)){const s=n(t[r]),o=n(i);t[r]="object"===s&&"object"===o?e(t[r],i):"array"===s&&"array"===o?t[r].concat(i):i}return t},recursiveFreeze:function e(t){for(const[n,r]of Object.entries(t))r&&"object"==typeof r&&e(r);return Object.freeze(t)},regularExpressions:v,typeOf:n,typedObjectLiteral:r,variables:f});function D(e){if(e.length<3)return"{"+e+"}";for(var t=-1,n=2;n<e.length;n++)if("."===e[n]&&"."===e[n-1]&&(n<2||"\\"!==e[n-2])){if(t>-1)return"{"+e+"}";t=n-1}if(t>-1){var r=e.substr(0,t),s=e.substr(t+2);if(r.length>0&&s.length>0)return"["+e.substr(0,t)+"-"+e.substr(t+2)+"]"}return"{"+e+"}"}function $(e){if("string"!=typeof e)throw new TypeError("A pattern must be a string, but "+typeof e+" given");for(var t,n=!1,r=0,s=0,i=-1,o=[""],a=[],c=0;c<e.length;c++){var l=e[c];if("\\"!==l){if("{"===l)if(n)r++;else if(c>i&&!r){t=e.substring(i+1,c);for(var p=0;p<o.length;p++)o[p]+=t;a=[],i=c,n=!0,r++}else r--;else if("}"===l)if(n)s++;else if(1===s){if(t=e.substring(i+1,c),a.length>0){var u=[];a.push($(t));for(p=0;p<o.length;p++)for(var d=0;d<a.length;d++)for(var h=0;h<a[d].length;h++)u.push(o[p]+a[d][h]);o=u}else{t=D(t);for(p=0;p<o.length;p++)o[p]+=t}i=c,s--}else s--;else n||","!==l||s-r!=1||(t=e.substring(i+1,c),a.push($(t)),i=c);!n||s!==r&&c!==e.length-1||(n=!1,c=i-1)}else c++}if(-1===i)return[e];var f="{"===e[i]?i:i+1;if(f<e.length){t=e.substr(f);for(p=0;p<o.length;p++)o[p]+=t}return o}function S(e,t){var n,r=!1!==t["!"],s=!1!==t["()"],i=!1;if(r){for(n=0;n<e.length&&"!"===e[n];n++){if(s&&"("===e[n+1]){n--;break}i=!i}n>0&&(e=e.substr(n))}return{pattern:e,isNegated:i}}function V(e){return"-"===e||"^"===e||"$"===e||"+"===e||"."===e||"("===e||")"===e||"|"===e||"["===e||"]"===e||"{"===e||"}"===e||"*"===e||"?"===e||"\\"===e?"\\"+e:e}function T(e,t,n){var r=void 0===t.separator||t.separator,s="",i="",o=".";!0===r?(s="/",i="[/\\\\]",o="[^/\\\\]"):o=r?(i=function(e){for(var t="",n=0;n<e.length;n++)t+=V(e[n]);return t}(s=r)).length>1?"((?!"+(i="(?:"+i+")")+").)":"[^"+i+"]":".";var a=r?i+"+?":"",c=r?i+"*?":"",l=r?e.split(s):[e];return{source:e,segments:l,options:t,separator:r,separatorSplitter:s,separatorMatcher:i,optionalSeparator:c,requiredSeparator:a,wildcard:o,support:{qMark:!1!==t["?"],star:!1!==t["*"],globstar:r&&!1!==t["**"],brackets:!1!==t["[]"],extglobs:!1!==t["()"],excludeDot:n&&!1!==t.excludeDot}}}function _(e,t,n,r){return{source:e,isFirst:n,isLast:r,end:e.length-1}}var q="(?!\\.)";function L(e,t,n){return e.addToUnmatch&&(e.result.unmatch+=t),e.addToMatch&&(n&&!e.dotHandled&&(t=q+t),e.dotHandled=!0,e.result.match+=t),e.result}function I(e,t,n){var r=e.support,s=function(e,t,n){return{pattern:e,segment:t,result:n,openingBracket:t.end+1,closingBracket:-1,openingParens:0,closingParens:0,parensHandledUntil:-1,extglobModifiers:[],scanningForParens:!1,escapeChar:!1,addToMatch:!0,addToUnmatch:e.support.extglobs,dotHandled:!1,i:-1,char:"",nextChar:""}}(e,t,n),i=t.isLast?e.optionalSeparator:e.requiredSeparator;if(r.excludeDot||(s.dotHandled=!0),-1===t.end)return t.isLast&&!t.isFirst?n:L(s,i);if(r.globstar&&"**"===t.source)return L(s,"(?:"+((s.dotHandled?"":q)+e.wildcard+"*?"+i)+")*?");for(;++s.i<=t.end;){if(s.char=s.segment.source[s.i],s.nextChar=s.i<t.end?t.source[s.i+1]:"","\\"===s.char){if(s.i<s.segment.end){s.escapeChar=!0;continue}s.char=""}e=s.pattern,t=s.segment;var o=s.char,a=s.i;if(e.support.brackets&&!s.scanningForParens){if(a>s.openingBracket&&a<=s.closingBracket){s.escapeChar?L(s,V(o)):a===s.closingBracket?(L(s,"]"),s.openingBracket=t.source.length):"-"===o&&a===s.closingBracket-1?L(s,"\\-"):"!"===o&&a===s.openingBracket+1?L(s,"^"):L(s,"]"===o?"\\]":o),s.escapeChar=!1;continue}if(a>s.openingBracket){"]"===o&&!s.escapeChar&&a>s.openingBracket+1&&a>s.closingBracket?(s.closingBracket=a,s.i=s.openingBracket,e.separator?L(s,"(?!"+e.separatorMatcher+")[",!0):L(s,"[",!0)):a===t.end&&(L(s,"\\["),s.i=s.openingBracket,s.openingBracket=t.source.length,s.closingBracket=t.source.length),s.escapeChar=!1;continue}if("["===o&&!s.escapeChar&&a>s.closingBracket&&a<t.end){s.openingBracket=a,s.escapeChar=!1;continue}}if(s.pattern.support.extglobs){var c=s.extglobModifiers,l=(o=s.char,s.nextChar);a=s.i;if("("!==l||s.escapeChar||"@"!==o&&"?"!==o&&"*"!==o&&"+"!==o&&"!"!==o){if(")"!==o||s.escapeChar){if("|"===o&&s.closingParens&&!s.scanningForParens&&!s.escapeChar){L(s,"|");continue}}else if(s.scanningForParens)s.closingParens++;else if(c.length){var p=c.pop();if("!"===p&&-1!==c.indexOf("!"))throw new Error("Nested negated extglobs aren't supported");L(s,")"+(p="!"===p||"@"===p?"":p)),s.addToMatch=!0,s.addToUnmatch=!0,s.closingParens--;continue}}else if(s.scanningForParens)s.openingParens++;else if(a>s.parensHandledUntil&&!s.closingParens)s.parensHandledUntil=a,s.scanningForParens=!0,s.openingParens++;else{if(s.closingParens>=s.openingParens){"!"===o&&(s.addToMatch=!0,s.addToUnmatch=!1,L(s,s.pattern.wildcard+"*?",!0),s.addToMatch=!1,s.addToUnmatch=!0,s.result.useUnmatch=!0),c.push(o),L(s,"(?:",!0),s.openingParens--,s.i++;continue}s.openingParens--}if(s.scanningForParens){s.closingParens!==s.openingParens&&a!==s.segment.end||(s.scanningForParens=!1,s.i=s.parensHandledUntil-1),s.escapeChar=!1;continue}}r=(e=s.pattern).support;!s.escapeChar&&r.star&&"*"===s.char?s.i!==s.segment.end&&"*"===s.nextChar||L(s,e.wildcard+"*?",!0):!s.escapeChar&&r.qMark&&"?"===s.char?L(s,e.wildcard,!0):L(s,V(s.char)),s.escapeChar=!1}return L(s,i)}function C(e,t,n){for(var r=T(e,t,n),s={match:"",unmatch:"",useUnmatch:!1},i=r.segments,o=0;o<i.length;o++){I(r,_(i[o],0,0===o,o===i.length-1),s)}return s.useUnmatch?"(?!^"+s.unmatch+"$)"+s.match:s.match}function z(e,t){if("string"!=typeof t)throw new TypeError("Sample must be a string, but "+typeof t+" given");return e.test(t)}function N(e,t){if("string"!=typeof e&&!Array.isArray(e))throw new TypeError("The first argument must be a single pattern string or an array of patterns, but "+typeof e+" given");if("string"!=typeof t&&"boolean"!=typeof t||(t={separator:t}),2===arguments.length&&void 0!==t&&("object"!=typeof t||null===t||Array.isArray(t)))throw new TypeError("The second argument must be an options object or a string/boolean separator, but "+typeof t+" given");if("\\"===(t=t||{}).separator)throw new Error("\\ is not a valid separator");var n=function(e,t){e=Array.isArray(e)?e:[e],!1!==t["{}"]&&(e=function(e,t){for(var n=[],r=0;r<e.length;r++)for(var s=t(e[r]),i=0;i<s.length;i++)n.push(s[i]);return n}(e,$));for(var n=[],r=[],s="",i=0;i<e.length;i++){var o=S(e[i],t),a=C(o.pattern,t,!o.isNegated);o.isNegated?r.push(a):n.push(a)}return r.length&&(s="(?!(?:"+r.join("|")+")$)"),n.length>1?s+="(?:"+n.join("|")+")":1===n.length?s+=n[0]:s.length&&(s+=C("**",t,!0)),"^"+s+"$"}(e,t),r=new RegExp(n,t.flags),s=z.bind(null,r);return s.options=t,s.pattern=e,s.regexp=r,s}class R{#e;#t;#n;#r=!1;#s;#i=[];#o=[];#a=[];#c=[];#l=[];#p;#u;#d;constructor(t,n){if(!t||!n)return this;this.#e=((t={})=>{const n={enable:!1,accessors:[e.default],propertyDirectory:{scopeKey:t.scopeKey,maxDepth:10},assign:"addEventListener",deassign:"removeEventListener",transsign:"dispatchEvent",bindListener:!0,scopeKey:":scope",errorLog:!1,methods:{assign:{addEventListener:function(e,t){const{type:n,listener:r,settings:s}=e,{options:i,useCapture:o}=s;return t.addEventListener(n,r,i||o)},on:function(e,t){const{type:n,listener:r}=e;return t.on(n,r)},once:function(e,t){const{type:n,listener:r}=e;return t.once(n,r)}},deassign:{removeEventListener:function(e,t){const{type:n,listener:r,settings:s}=e,{options:i,useCapture:o}=s;return t.removeEventListener(n,r,i||o)},off:function(e,t){const{type:n,listener:r}=e;return t.off(n,r)}},transsign:{dispatchEvent:function(e,t,n){return t.dispatchEvent(n)},emit:function(e,t,n,...r){return t.emit(n,...r)}}}};for(const[e,r]of Object.entries(t))switch(e){case"propertyDirectory":n[e]=Object.assign(n[e],r);break;case"accessors":n[e]=r,n.propertyDirectory[e]=r;break;case"methods":n[e]=k(n[e],r);break;case"enableEvents":break;default:n[e]=r}return n})(t),this.#t=n,this.enable=this.settings.enable}get settings(){return this.#e}get path(){return this.settings.path}get type(){return this.settings.type}get listener(){if(void 0!==this.#n)return this.#n;const e=this.settings.listener;return!0===this.settings.bindListener?this.#n=e.bind(this.#t):this.#n=e,this.#n}get enable(){return this.#r}set enable(e){const t=this.#h,n=this.#i,r=this.#o;n.length=0,r.length=0;for(const s of t){const{path:t,target:i,enable:o}=s;if(this.settings,o!==e)if(!0===e)try{this.#f(i),s.enable=e,n.push(s)}catch(e){this.settings.errorLog&&console.error(e)}else if(!1===e)try{this.#v(i),s.enable=e,r.push(s)}catch(e){this.settings.errorLog&&console.error(e)}}this.#r=e}get assigned(){return this.#i}get deassigned(){return this.#o}get#g(){return this.settings.target}get#h(){const e=this.#l,t=[];if(this.#g)for(const n of[].concat(this.#g)){const r=e.find((e=>e?.path===this.path));void 0!==r?t.push(r):void 0===r&&t.push({path:this.path,target:n,enable:!1})}else if("string"===n(this.path)){const n=[];if(this.path===this.#y){const e={path:this.path,target:this.#t,enable:!1};t.push(e)}else{if(this.settings.propertyDirectory){const e=this.#b,t=N(this.path,{separator:"."});for(const r of e){!0===t(r)&&n.push(r)}"*"===this.path.charAt(0)&&n.unshift(this.#y)}else n.push(this.path);for(const r of n){const n=e.find((e=>e.path===r));let s,i=this.#t;const o=r.split(".");let a=0;e:for(;a<o.length;){let e=o[a];if(e===this.#y)break e;t:for(const t of this.settings.accessors){try{i=t(i,e)}catch(e){this.settings.errorLog&&console.error(e)}if(void 0!==i)break t}a++}void 0!==i&&(i===n?.target?s=n:"object"==typeof i&&(s={path:r,target:i,enable:!1})),void 0!==s&&t.push(s)}}}return this.#l=t,this.#l}get#y(){return this.settings.scopeKey}get#f(){return void 0!==this.#p||(this.#p=this.settings.methods.assign[this.settings.assign].bind(null,this)),this.#p}get#v(){return void 0!==this.#u||(this.#u=this.settings.methods.deassign[this.settings.deassign].bind(null,this)),this.#u}get#j(){return void 0!==this.#d||(this.#d=this.settings.methods.transsign[this.settings.transsign].bind(null,this)),this.#d}get#m(){return this.settings.methods}get#b(){if(!this.settings.propertyDirectory)return null;const e=(this.settings.accessors,this.settings.propertyDirectory);return w(this.#t,e)}emit(){const e=this.#h,t=this.#a,n=this.#c;t.length=0,n.length=0;for(const r of e){const{target:e}=r;try{this.#j(e,...arguments),t.push(r)}catch(e){n.push(r)}}return this}}class B extends EventTarget{static implement=function(e,n){if(!e||!n)return;const r=((e={})=>{const t={events:{},enableEvents:!1,propertyDefinitions:{getEvents:"getEvents",addEvents:"addEvents",removeEvents:"removeEvents",enableEvents:"enableEvents",disableEvents:"disableEvents",reenableEvents:"reenableEvents",emitEvents:"emitEvents"}};for(const[n,r]of Object.entries(e))t[n]="propertyDefinitions"===n?Object.assign(t[n],r):r;return t})(n),s=[];return Object.defineProperties(e,{[r.propertyDefinitions.getEvents]:{enumerable:!1,writable:!1,value:function(){if(!arguments[0])return s;const e=[],t=[].concat(arguments[0]);for(const n of t)for(const t of s){let r;e:for(const[e,s]of Object.entries(n)){let n;if(n="listener"===e?t.settings[e]===s:t[e]===s,!1===r)break e;r=n}!0===r&&e.push(t)}return e}},[r.propertyDefinitions.addEvents]:{enumerable:!1,writable:!1,value:function(){if(!arguments.length)return e;let n=t(arguments[0],r.scopeKey);for(let t of n){const n={};for(const e of["accessors","assign","deassign","transsign","propertyDirectory"]){const t=r[e];void 0!==t&&(n[e]=t)}k(n,t);const i=new R(n,e);s.push(i)}return e}},[r.propertyDefinitions.removeEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[r.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;let n=s.length-1;for(;n>-1;){const e=s[n];t.includes(e)&&(e.enable=!1,s.splice(n,1)),n--}return e}},[r.propertyDefinitions.enableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[r.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;for(const e of t)e.enable=!0;return e}},[r.propertyDefinitions.disableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[r.propertyDefinitions.getEvents](arguments[0]);if(0===t.length)return e;for(const e of t)e.enable=!1;return e}},[r.propertyDefinitions.reenableEvents]:{enumerable:!1,writable:!1,value:function(){const t=e[r.propertyDefinitions.getEvents](arguments[0]);for(const e of t)e.enable=!1,e.enable=!0;return e}},[r.propertyDefinitions.emitEvents]:{enumerable:!1,writable:!1,value:function(t,...n){const s=e[r.propertyDefinitions.getEvents](t);for(const e of s)e.emit(...n);return e}}}),r.events&&e[r.propertyDefinitions.addEvents](r.events),!0===r.enableEvents&&e[r.propertyDefinitions.enableEvents](),e};constructor(e={}){return super(),B.implement(this,e)}}class K extends EventTarget{#e;#O;#P;constructor(e){super(),this.#e=e}get type(){return this.#e.type}get definition(){return this.#e.definition}get key(){return this.#e.key}get value(){return this.#e.value}get message(){return void 0!==this.#O||void 0!==this.pass&&void 0===this.#O&&(this.#O=this.#e.messages[String(this.pass)](this)),this.#O}get pass(){return this.#P}set pass(e){void 0===this.#P&&(this.#P=e)}}const{recursiveAssign:M}=A,F={true:e=>`${e.pass}`,false:e=>`${e.pass}`};class U extends EventTarget{#E;#x;#w;constructor(e={},t){super(),this.definition=Object.freeze(Object.assign({messages:F},e)),this.schema=t}get definition(){return this.#x}set definition(e){this.#x=e}get schema(){return this.#w}set schema(e){return void 0!==this.#w||(this.#w=e),this.#w}get type(){return this.definition.type}get messages(){return this.definition.messages}get validate(){return this.#E=function(e,t,n,r){const s=this.definition,i=new K({type:this.type,definition:s,key:e,value:t,messages:M({},this.messages,s.messages)});return i.pass=s.validate(...arguments),i}.bind(this),this.#E}}const{recursiveAssign:W,typedObjectLiteral:H}=A;class J extends U{constructor(e,t){super(Object.assign(e,{type:"required",validate:(e,t,n,r)=>{let s;this.definition;const{requiredProperties:i,requiredPropertiesSize:o,type:a}=this.schema;if(0===o)s=!0;else if("object"===a){const t=H(a),o=H(a);e:for(const[s,a]of Object.entries(i)){const i=W({},a);if(i.required.value=!1,s===e)continue e;const c=Object.getOwnPropertyDescriptor(n,s);if(void 0!==c)t[s]=i,o[s]=c.value;else if(r){if(void 0!==Object.getOwnPropertyDescriptor(r,s))continue e;t[s]=i}else t[s]=i}const c=Object.keys(t).length,l=Object.keys(o).length;if(0===c&&0===l)s=!0;else if(c!==l)s=!1;else{const e=new ve(t,Object.assign({},this.schema.options,{required:!1})),i=[];for(const[t,s]of Object.entries(o)){const s=o[t],a=e.validateProperty(t,s,n,r);i.push(a)}s=!i.find((e=>!1===e.valid))}}else"array"===a&&(s=!0);return s}}),t)}}const{typeOf:G,variables:Q}=A,{PrimitiveKeys:X,ObjectKeys:Y}=Q;class Z extends U{constructor(e={},t){super(Object.assign(e,{type:"type",validate:(e,t)=>{let n;const r=this.definition,s="function"===G(r.value)?G(r.value()):s;if(X.concat(Y).includes(s)){const e=G(t);n="undefined"!==e&&("undefined"===s||s===e)}else n=!1;return n}}),t)}}class ee extends U{constructor(e={},t){super(Object.assign(e,{type:"range",validate:(e,t)=>{const n=this.definition;let r;if("number"!=typeof t)r=!1;else{const{min:e,max:s}=n;let i,o;i=void 0===e||t>=e.value,o=void 0===s||t<=s.value,r=!(!i||!o)}return r}}),t)}}class te extends U{constructor(e={},t){super(Object.assign(e,{type:"length",validate:(e,t)=>{const n=this.definition;let r;if("string"!=typeof t)r=!1;else{const{min:e,max:s}=n;let i,o;i=void 0===e||t.length>=e.value,o=void 0===s||t.length<=s.value,r=!(!i||!o)}return r}}),t)}}class ne extends U{constructor(e={},t){super(Object.assign(e,{type:"enum",validate:(e,t)=>{const n=this.definition;let r;if(["string","number","boolean"].includes(typeof t)){r=n.value.includes(t)}else r=!1;return r}}),t)}}class re extends U{constructor(e={},t){super(Object.assign(e,{type:"match",validate:(e,t)=>{const n=this.settings;let r;if(["string","number","boolean"].includes(typeof t)){n.value.exec(t)}else r=!1;return!!r}}),t)}}class se{#t;constructor(e){this.#t=e}}const{expandTree:ie,isPropertyDefinition:oe,typedObjectLiteral:ae,typeOf:ce,variables:le}=A;class pe extends EventTarget{#k;#w;#A;#D;#g;#$;constructor(e,t){return super(),this.#k=e,this.schema=t,this.proxy}get required(){return this.schema.options.required}get schema(){return this.#w}set schema(e){if(void 0===this.#w)return this.#w=e,this.#w}get type(){return void 0!==this.#A||(this.#A=ce(ae(this.#k))),this.#A}get proxy(){return void 0!==this.#D||(this.#D=new Proxy(this.target,this.#S)),this.#D}get#S(){return void 0!==this.#$||(this.#$=new se(this)),this.#$}get target(){if(void 0!==this.#g)return this.#g;let e;const t=ae(this.type);"array"===this.type?e=this.#k.slice(0,1):"object"===this.type&&(e=this.#k);for(const[n,r]of Object.entries(e)){const e=ce(r);let s;if(r instanceof ve)s=r;else if(le.TypeValues.includes(r))s=ie(r,"type.value");else if(le.TypeKeys.includes(r))s=ie(le.TypeValues[le.TypeKeys.indexOf(r)],"type.value");else if(["array","object"].includes(e)){let e=oe(r);if(!1===e){const{path:e}=this.schema,t=e?[e,n].join("."):String(n),i=this.schema;s=new ve(r,Object.assign({},this.schema.options,{path:t,parent:i}))}else if(!0===e){s={validators:[]};e:for(const[e,t]of Object.entries(r)){if("validators"===e)continue e;let n;n="object"===ce(t)?t:{value:t},s[e]=n}r.validators=r.validators||[];for(const e of r.validators)for(const t of[J,Z,ee,te,ne,re])e instanceof t==!1&&s.validators.push(e)}}s instanceof ve==!1&&(s=this.#V(s)),t[n]=s}return this.#g=t,this.#g}#V(e){const t=e;t.validators=[];const n=new Map,r=this.required,{required:s,type:i,range:o,min:a,max:c,length:l,minLength:p,maxLength:u,match:d}=t;!0===r||!0===s?.value?n.set("required",Object.assign({},t.required,{type:"required",value:!0,validator:J})):n.set("required",Object.assign({},t.required,{type:"required",value:!1,validator:J})),i?n.set("type",Object.assign({},i,{type:"type",validator:Z})):n.set("type",Object.assign({},i,{type:"type",value:void 0,validator:Z})),o?n.set("range",Object.assign({},o,{type:"range",validator:ee})):(a||c)&&n.set("range",Object.assign({},{type:"range",min:a,max:c,validator:ee})),l?n.set("length",Object.assign({},l,{type:"length",validator:te})):(p||u)&&n.set("length",Object.assign({},{type:"length",min:p,max:u,validator:te})),t.enum&&n.set("enum",Object.assign({},t.enum,{type:"enum",validator:ne})),d&&n.set("match",Object.assign({},d,{type:"match",validator:re})),delete t.min,delete t.max,delete t.minLength,delete t.maxLength;for(const[e,r]of n.entries()){const n=r.validator;t[e]=r,t.validators.push(new n(r,this.schema))}return t}}const ue={true:e=>`${e.valid}`,false:e=>`${e.valid}`};class de extends EventTarget{#e;#k;#T;#_=[];#q=[];#L=[];constructor(e={}){super(),this.#e=Object.assign({messages:ue},e)}get definition(){return this.#e.definition}get path(){return this.#e.path}get key(){return this.#e.key}get value(){return this.#e.value}get properties(){return void 0!==this.#k||(this.#k=this.#e.properties),this.#k}get advance(){return this.#_}get deadvance(){return this.#q}get unadvance(){return this.#L}get valid(){return this.#T}set valid(e){void 0===this.#T&&(this.#T=e)}}const{typedObjectLiteral:he,typeOf:fe}=A;class ve extends EventTarget{constructor(e={},t={}){super(),Object.defineProperty(this,"options",{configurable:!0,get(){const e=((...e)=>Object.assign({required:!1,verificationType:"all"},...e))(t);return Object.defineProperty(this,"options",{value:e}),e}}),Object.defineProperty(this,"type",{configurable:!0,get(){const t=fe(e);return Object.defineProperty(this,"options",{value:t}),t}}),Object.defineProperty(this,"parent",{configurable:!0,get(){const e=this.options.parent?this.options.parent:null;return Object.defineProperty(this,"parent",{value:e}),e}}),Object.defineProperty(this,"root",{configurable:!0,get(){let e=this;e:for(;e&&![void 0,null].includes(e.parent);)e=e.parent;return e}}),Object.defineProperty(this,"key",{configurable:!0,get(){const e=this.path?this.path.split(".").pop():null;return Object.defineProperty(this,"key",{value:e}),e}}),Object.defineProperty(this,"path",{configurable:!0,get(){const e=this.options.path?String(this.options.path):null;return Object.defineProperty(this,"path",{value:e}),e}}),Object.defineProperty(this,"required",{configurable:!0,get(){const e=this.options.required?this.options.required:null;return Object.defineProperty(this,"required",{value:e}),e}}),Object.defineProperty(this,"requiredProperties",{configurable:!0,get(){const e=he(this.type);for(const[t,n]of Object.entries(this.context))!0===n.required?.value&&(e[t]=n);return Object.defineProperty(this,"requiredProperties",{value:e}),e}}),Object.defineProperty(this,"requiredPropertiesSize",{configurable:!0,get(){const e=Object.keys(this.requiredProperties).length;return Object.defineProperty(this,"requiredPropertiesSize",{value:e}),e}}),Object.defineProperty(this,"verificationType",{configurable:!0,get(){const e=this.options.verificationType;return Object.defineProperty(this,"verificationType",{value:e}),e}}),Object.defineProperty(this,"context",{configurable:!0,get(){const t=new pe(e,this);return Object.defineProperty(this,"context",{value:t}),t}}),Object.defineProperty(this,"validate",{value:function(){const{$sourceName:e,$source:t,$target:n}=this.#I(...arguments),r=new de({definition:this.context,path:this.path,key:e,value:t,properties:he(this.type)}),s=Object.entries(t);let i=0,o=[];for(;i<s.length;){const[e,a]=s[i],c=this.validateProperty(e,a,t,n),l=c.deadvance.filter((e=>"required"===e.type));r.properties[e]=c,!0===c.valid?r.advance.push(c):!1===c.valid?r.deadvance.push(c):void 0===c.valid&&r.unadvance.push(c),o=o.concat(l),i++}return!0===this.required?r.deadvance.length?r.valid=!1:r.advance.length?r.valid=!0:r.unadvance.length?r.valid=void 0:r.valid=!1:!1===this.required&&(o.length?r.valid=!1:r.advance.length?r.valid=!0:r.deadvance.length?r.valid=!1:r.unadvance.length?r.valid=void 0:r.valid=!1),r}}),Object.defineProperty(this,"validateProperty",{value:function(){const{$key:e,$value:t,$source:n,$target:r}=this.#C(...arguments);let s;"array"===this.type?s=this.context[0]:"object"===this.type&&(s=this.context[e]);const{path:i}=this,o=i?[i,e].join("."):e,a=new de({definition:s,path:o,key:e,value:t});if(void 0===s){const n=new K({type:null,definition:null,key:e,value:t},this);n.pass=!1,a.unadvance.push(n)}else if(s instanceof ve){let n;n=r&&r[e]?s.validate(e,t,r[e]):s.validate(e,t),!0===n.valid?a.advance.push(n):!1===n.valid?a.deadvance.push(n):void 0===n.valid&&a.unadvance.push(n)}else e:for(const[i,o]of Object.entries(s.validators)){const s=o.validate(e,t,n,r);if(!0===s.pass?a.advance.push(s):!1===s.pass?a.deadvance.push(s):void 0===s.pass&&a.unadvance.push(s),"one"===this.verificationType&&a.deadvance.length)break e}return a.deadvance.length?a.valid=!1:a.advance.length?a.valid=!0:a.unadvance.length&&(a.valid=!1),a}})}#I(){let e,t,n,r=[...arguments];return 1===r.length?(e=null,t=r.shift(),n=null):2===r.length&&"string"==typeof r[0]?(e=r.shift(),t=r.shift(),n=null):2===r.length&&r[0]&&"object"==typeof r[0]?(e=null,t=r.shift(),n=r.shift()):3===r.length&&"string"==typeof r[0]&&(e=r.shift(),t=r.shift(),n=r.shift()),{$sourceName:e,$source:t,$target:n}}#C(){let e=[...arguments],[t,n,r,s]=e;r=r instanceof tt?r.valueOf():r;return s=s instanceof tt?s.valueOf():s,{$key:t,$value:n,$source:r,$target:s}}}const{recursiveAssign:ge}=A;class ye extends CustomEvent{constructor(e,t,n){super(e,t),Object.defineProperties(this,{model:{get:()=>n},key:{configurable:!0,get(){const e=this.path?this.path.split(".").pop():null;return Object.defineProperty(this,"key",{value:e}),e}},change:{configurable:!0,get(){const e=t.change;return Object.defineProperty(this,"change",{value:e}),e}},value:{configurable:!0,get(){const e=t.value;return Object.defineProperty(this,"value",{value:e}),e}},path:{configurable:!0,get(){const e=t.path;return Object.defineProperty(this,"path",{value:e}),e}},detail:{configurable:!0,get(){const e=t.detail;return Object.defineProperty(this,"detail",{value:e}),e}}})}}class be{#z=!1;#N=!1;#R=!1;#B=!1;#K;#M;#F;#U;constructor(e={}){for(const[t,n]of Object.entries(e))this[t]=n}get preter(){return this.#M}set preter(e){if(!0===this.#N)return this.#M;this.#M=e?.valueOf(),this.#N=!0}get anter(){return this.#F}set anter(e){if(!0===this.#R)return this.#F;this.#F=e?.valueOf(),this.#R=!0}get conter(){if(!0===this.#B||[this.#N,this.#R].includes(!1))return this.#U;const e=JSON.stringify(this.preter);let t;return t=JSON.stringify(this.anter)!==e,this.#U=t,this.#B=!0,this.#U}}let je=class extends CustomEvent{constructor(e,t,n){super(e),Object.defineProperties(this,{key:{configurable:!0,get(){const e=t.key;return Object.defineProperty(this,"key",{value:e}),e}},path:{configurable:!0,get(){const e=t.path;return Object.defineProperty(this,"path",{value:e}),e}},value:{configurable:!0,get(){const e=t.value;return Object.defineProperty(this,"value",{value:e}),e}},valid:{configurable:!0,get(){const e=t.valid;return Object.defineProperty(this,"valid",{value:e}),e}}})}};const{recursiveAssign:me,typedObjectLiteral:Oe}=A;const{impandTree:Pe,typedObjectLiteral:Ee}=A;const{recursiveAssign:xe,typedObjectLiteral:we}=A;var ke={assign:function(e,t,...n){const r=Object.assign({},t),s=r.assignArray||"assign",{path:i,target:o,schema:a}=e,{mutatorEvents:c,sourceTree:l,enableValidation:p,validationEvents:u}=r,d=[],h=new be({preter:e});for(let t of n){let n;const h=new be({preter:e});Array.isArray(t)?n=[]:t&&"object"==typeof t&&(n={});e:for(let[d,h]of Object.entries(t)){const f=new be({preter:o[d]}),v=new be({preter:o[d]});if(a&&p){const n=a.validateProperty(d,h,t,e);if(u){let t,r;n.valid?(t="validProperty",r=["validProperty",d].join(":")):(t="nonvalidProperty",r=["nonvalidProperty",d].join(":"));for(const s of[t,r])e.dispatchEvent(new je(s,n,e))}if(!n.valid)continue e}let g;if(h&&"object"==typeof h){let t;h instanceof e.constructor&&(g=h.valueOf()),t="array"===a?.type?a.context[0]:"object"===a?.type?a.context[d]:null;const c=i?[i,d].join("."):String(d);if(!1===l){const s=me({},r,{path:c,parent:e});g=new e.constructor(h,t,s);const i={[d]:g};Object.assign(o,i),Object.assign(n,i)}else{if(o[d]instanceof e.constructor)g=o[d];else{const n=Oe(h),s=me({},r,{path:c,parent:e});g=new e.constructor(n,t,s)}const i={[d]:g};Object.assign(o,i),Object.assign(n,i),e.retroReenableEvents(),"array"===g.type?["push","unshift"].includes(s)?g[s](...h):g[s](h):"object"===g.type&&g.assign(h)}}else{g=h;const e={[d]:g};Object.assign(o,e),Object.assign(n,e)}if(c){const t=i?[i,d].join("."):String(d);if(c["assignSourceProperty:$key"]){const r=["assignSourceProperty",d].join(":");v.anter=o[d],e.dispatchEvent(new ye(r,{path:t,value:g,change:v,detail:{source:n}},e))}c.assignSourceProperty&&(f.anter=o[d],e.dispatchEvent(new ye("assignSourceProperty",{path:t,value:g,change:f,detail:{source:n}},e)))}}d.push(n),c&&c.assignSource&&(h.anter=e,e.dispatchEvent(new ye("assignSource",{path:i,change:h,detail:{source:n}},e)))}return c&&c.assign&&(h.anter=e,e.dispatchEvent(new ye("assign",{path:i,change:h,detail:{sources:d}},e))),e},defineProperties:function(e,t,n){const{mutatorEvents:r}=t,{path:s}=e,i=Object.entries(n);Ee(e.valueOf());const o=new be({preter:e});for(const[t,n]of i)e.defineProperty(t,n);return r&&r.defineProperties&&(o.anter=e,e.dispatchEvent(new ye("defineProperties",{path:s,value:e.valueOf(),detail:{descriptors:n}},e))),e},defineProperty:function(e,t,n,r){const s=Object.assign({},t),i=s.assignArray||"defineProperties",{descriptorTree:o,enableValidation:a,mutatorEvents:c,validationEvents:l}=s,{target:p,path:u,schema:d}=e,h=r.value,f=(Object.getOwnPropertyDescriptor(p,n)||{}).value,v=new be({preter:f}),g=new be({preter:f}),y=f instanceof e.constructor;if(d&&a){const t=d.validateProperty(n,h,e);if(l){let r,s;t.valid?(r="validProperty",s=["validProperty",n].join(":")):(r="nonvalidProperty",s=["nonvalidProperty",n].join(":"));for(const n of[r,s])e.dispatchEvent(new je(n,t,e))}if(!t.valid)return e}if(h&&"object"==typeof h){const t=u?[u,n].join("."):String(n);if(y)!0===o?f.defineProperties(r):Object.defineProperty(p,n,r);else{let a;d&&(a="array"===d.type?d.context[0]:"object"===d.type?d.context[n]:void 0);let c=we(h);const l=xe({},s,{path:t,parent:e}),u=new e.constructor(c,a,l);!0===o?(p[n]=u,e.retroReenableEvents(),"array"===u.type?["push","unshift"].includes(i)?u[i](...h):u[i](h):"object"===u.type&&u.defineProperties(h)):!1===o&&Object.defineProperty(p,n,r)}}else Object.defineProperty(p,n,r);if(c){const t=u?[u,n].join("."):String(n);if(c["defineProperty:$key"]){g.anter=p[n];const s=["defineProperty",n].join(":");e.dispatchEvent(new ye(s,{path:t,value:h,change:g,detail:{prop:n,descriptor:r}},e))}c.defineProperty&&(v.anter=p[n],e.dispatchEvent(new ye("defineProperty",{path:t,value:h,change:v,detail:{prop:n,descriptor:r}},e)))}return e},freeze:function(e,t){const{recursive:n,mutatorEvents:r}=t,{target:s}=e;if(!0===n)for(const[t,n]of Object.entries(s))n instanceof e.constructor&&(n.freeze(),r&&r.freezeProperty&&e.dispatchEvent(new ye("freezeProperty",{path:n.path},e)));return Object.freeze(s),r&&r.freeze&&e.dispatchEvent(new ye("freeze",{path:e.path},e)),e},seal:function(e,t){const{recursive:n,mutatorEvents:r}=t,{target:s}=e;if(!0===n)for(const[t,n]of Object.entries(s))n instanceof e.constructor&&(n.seal(),r&&r.sealProperty&&e.dispatchEvent(new ye("sealProperty",{path:n.path},e)));return Object.seal(s),r&&r.seal&&e.dispatchEvent(new ye("seal",{path:e.path},e)),e}};const{typedObjectLiteral:Ae}=A;const{typedObjectLiteral:De}=A;const{recursiveAssign:$e,typedObjectLiteral:Se,typeOf:Ve}=A;const{typedObjectLiteral:Te}=A;const{recursiveAssign:_e,typedObjectLiteral:qe,typeOf:Le}=A;var Ie={concat:function(e,t){const{target:n,path:r,schema:s}=e,{enableValidation:i,validationEvents:o,mutatorEvents:a}=t,c=[].concat(...arguments);let l=n.length;const p=[];let u,d=[...Array.from(n)];e:for(let t of c){if(s&&i){const t=s.validateProperty(l,$subvalue,{},e);if(s&&o){let n,r;t.valid?(n="validProperty",r=["validProperty",l].join(":")):(n="nonvalidProperty",r=["nonvalidProperty",l].join(":"));for(const s of[n,r])e.dispatchEvent(new ValidatorEvent(s,t,e))}if(!t.valid){l++;continue e}}const n=r?[r,l].join("."):String(l);if(t&&"object"==typeof t){t instanceof e.constructor&&(t=t.valueOf());let r=s?.context[0]||null;const i=Ae(t);let o=new e.constructor(i,r,{path:n,parent:e});o.concat(t),p[l]=o}else p[l]=t;if(d=Array.prototype.concat.call(d,p[l]),a){const t=r?[r,l].join("."):String(l);a.concatValue&&e.dispatchEvent(new ye("concatValue",{path:t,value:p[l],detail:{valueIndex:l,value:p[l]}},e)),a["concatValue:$index"]&&e.dispatchEvent(new ye("concatValue",{path:t,value:p[l],detail:{valueIndex:l,value:p[l]}},e))}l++}return u=new e.constructor(d,s,e.options),a&&a.concat&&e.dispatchEvent(new ye("concat",{path:r,detail:{values:u}},e)),u},copyWithin:function(e,t){const{target:n,path:r}=e,{enableValidation:s,validationEvents:i,mutatorEvents:o}=t,a=arguments[0]>=0?arguments[0]:n.length=arguments[0],c=arguments[1]>=0?arguments[1]:n.length+arguments[1],l=void 0===arguments[2]?n.length:arguments[2]>=0?arguments[2]:n.length+arguments[2],p=[];let u=c,d=a;for(;u<l;){const t=n[u];if(p.push(t),Array.prototype.copyWithin.call(n,d,u,u+1),e.retroReenableEvents(),o){const n=r?[r,u].join("."):String(u);if(o.copyWithinIndex&&e.dispatchEvent(new ye("copyWithinIndex",{path:n,value:t,detail:{target:d,start:u,end:u+1,item:t}},e)),o["copyWithinIndex:$index"]){const r=["copyWithinIndex",":",u].join("");e.dispatchEvent(new ye(r,{path:n,value:t,detail:{target:d,start:u,end:u+1,item:t}},e))}}u++,d++}return o&&o.copyWithin&&e.dispatchEvent(new ye("copyWithin",{path:r,detail:{target:a,start:c,end:l,items:p}},e)),e},fill:function(e,t,...n){const r=Object.assign({},t),{target:s,path:i,schema:o}=e,a=r.assignObject,c=r.assignArray||a,{enableValidation:l,lengthen:p,mutatorEvents:u,validationEvents:d}=r,h=[];let f,v;f="number"==typeof n[1]?n[1]>=0?n[1]:s.length+n[1]:0,v="number"==typeof n[2]?n[2]>=0?n[2]:s.length+n[2]:s.length,console.log(f,v),p&&s.length<v&&(s.length=v);let g=f;e:for(;g<s.length&&g<v;){if(o&&l){let t=o.validate(t);if(d){let n,r;t.valid?(n="validProperty",r=["validProperty",":",g].join("")):(n="nonvalidProperty",r=["nonvalidProperty",":",g].join(""));for(const s of[n,r])e.dispatchEvent(new ValidatorEvent(s,t,e))}if(!t.valid)continue e}const t=i?[i,g].join("."):String(g);let p,f=n[0];if(f&&"object"==typeof f){f instanceof e.constructor&&(f=f.valueOf());const n=o?.context[0]||null,s=De(f),i=Object.assign({},r,{path:t,parent:e});p=new e.constructor(s,n,i)}if(Array.prototype.fill.call(s,p,g,g+1),e.retroReenableEvents(),"array"===p.type?["push","unshift"].includes(c)?p[c](...f):p[c](f):"object"===p.type&&p[a](f),h.push(p),u){const t=i?[i,g].join("."):String(g);if(u.fillIndex&&e.dispatchEvent(new ye("fillIndex",{path:t,value:p,detail:{start:g,end:g+1,value:p}},e)),u["fillIndex:$index"]){const n=["fillIndex",":",g].join("");e.dispatchEvent(new ye(n,{path:t,detail:{start:g,end:g+1,value:p}},e))}}g++}return u&&u.fill&&e.dispatchEvent(new ye("fill",{path:i,detail:{start:f,end:v,filled:h}},e)),e},pop:function(e,t){const{mutatorEvents:n}=t,{target:r,path:s}=e,i=Array.prototype.pop.call(r),o=r.length-1;if(e.retroReenableEvents(),n&&n.pop){const t=s?[s,o].join("."):String(o);e.dispatchEvent(new ye("pop",{path:t,value:i,detail:{elementIndex:o,element:i}},e))}return i},push:function(e,t,...n){const r=Object.assign({},t),s="push",i=r.assignObject,{enableValidation:o,mutatorEvents:a,validationEvents:c}=r,{target:l,path:p,schema:u}=e,d=[];let h=0;for(let t of n){let n;if(u&&o){const n=u.validateProperty(h,t,{},e);if(c){let t,r;n.valid?(t="validProperty",r=["validProperty",":",h].join("")):(t="nonvalidProperty",r=["nonvalidProperty",":",h].join(""));for(const s of[t,r])e.dispatchEvent(new ValidatorEvent(s,n,e))}if(!n.valid)return l.length}const f=p?[p,h].join("."):String(h);if(t&&"object"==typeof t){t=t instanceof e.constructor?t.valueOf():t;const o=u?.context[0]||null,a=Se(Ve(t)),c=Object.assign({},r,{path:f,parent:e});n=new e.constructor(a,o,c),Array.prototype.push.call(l,n),e.retroReenableEvents(),"array"===n.type?["push","unshift"].includes(s)?n[s](...t):n[s](t):"object"===n.type&&n[i](t)}else n=t,Array.prototype.push.call(l,n);if(d.push(n),a){const t=p?[p,".",h].join(""):String(h);if(a.pushProp&&e.dispatchEvent(new ye("pushProp",{path:t,value:d[h],detail:{elementsIndex:h,element:d[h]}},e)),a["pushProp:$index"]){const n=["pushProp",":",h].join("");e.dispatchEvent(new ye(n,{path:t,value:d[h],detail:{elementsIndex:h,element:d[h]}},e))}}h++}return a&&a.push&&e.dispatchEvent(new ye("push",{path:p,detail:{elements:d}},e)),l.length},reverse:function(e,t){const{mutatorEvents:n}=t,{target:r,path:s}=e;return Array.prototype.reverse.call(r,...arguments),e.retroReenableEvents(),n&&n.reverse&&e.dispatchEvent(new ye("reverse",{path:s,detail:{reference:r}},e)),e},shift:function(e,t){const{mutatorEvents:n}=t,{target:r,path:s}=e,i=Array.prototype.shift.call(r),o=0;if(e.retroReenableEvents(),n&&n.shift){const t=s?[s,o].join("."):String(o);e.dispatchEvent(new ye("shift",{path:t,value:i,detail:{elementIndex:o,element:i}},e))}return i},splice:function(e,t){const n=Object.assign({},t),r=n.assignObject,s=n.assignArray||r,{mutatorEvents:i}=n,{target:o,path:a,schema:c}=e,{enableValidation:l,validationEvents:p}=n,u=[...arguments],d=u[0]>=0?u[0]:o.length+u[0],h=u[1]<=0?0:void 0===u[1]||d+u[1]>=o.length?o.length-d:u[1],f=u.slice(2),v=f.length,g=[];let y=0;for(;y<h;){const t=Array.prototype.splice.call(o,d,1)[0];if(g.push(t),i){const n=a?[a,y].join("."):String(y);if(i.spliceDelete&&e.dispatchEvent(new ye("spliceDelete",{path:n,value:t,detail:{index:d+y,deleteIndex:y,deleteItem:t}},e)),i["spliceDelete:$index"]){const r=["spliceDelete",":",y].join("");e.dispatchEvent(new ye(r,{path:n,value:t,detail:{index:d+y,deleteIndex:y,deleteItem:t}},e))}}y++}let b=0;e:for(;b<v;){let t=f[b];if(c&&l){const t=c.validateProperty(elementIndex,element,{},e);if(p){let n,r;t.valid?(n="validProperty",r=["validProperty",":",b].join("")):(n="nonvalidProperty",r=["nonvalidProperty",":",b].join(""));for(const s of[n,r])e.dispatchEvent(new ValidatorEvent(s,t,e))}if(!t.valid){b++;continue e}}const u=a?[a,b].join("."):String(b);let h=d+b;if(t&&"object"==typeof t){t instanceof e.constructor&&(t=t.valueOf());const i=c?.context[0]||null,a=Te(t),l=recursiveAssign({},n,{path:u,parent:e});t=new e.constructor(a,i,l),Array.prototype.splice.call(o,h,0,t),e.retroReenableEvents(),"array"===t.type?["push","unshift"].includes(s)?t[s](...$value):t[s]($value):"object"===t.type&&t[r]($value)}else Array.prototype.splice.call(o,h,0,t);if(i){const n=a?[a,b].join("."):String(b);if(i.spliceAdd&&e.dispatchEvent(new ye("spliceAdd",{path:n,value:t,detail:{index:d+b,addIndex:b,addItem:t}},e)),i["spliceAdd:$index"]){const r=["spliceAdd",":",b].join("");e.dispatchEvent(new ye(r,{path:n,value:t,detail:{index:d+b,addIndex:b,addItem:t}},e))}}b++}return i&&i.splice&&e.dispatchEvent(new ye("splice",{path:a,detail:{$start:d,deleted:g,added:f,length:o.length}},e)),g},unshift:function(e,t,...n){const r=Object.assign({},t),s=r.assignObject,{enableValidation:i,mutatorEvents:o,validationEvents:a}=r,{target:c,path:l,schema:p}=e,u=[];let d=0;for(let t of n){let n;if(p&&i){const n=p.validateProperty(d,t,{},e);if(a){let t,r;n.valid?(t="validProperty",r=["validProperty",":",d].join("")):(t="nonvalidProperty",r=["nonvalidProperty",":",d].join(""));for(const s of[t,r])e.dispatchEvent(new ValidatorEvent(s,n,e))}if(!n.valid)return c.length}const h=l?[l,d].join("."):String(d);if(t&&"object"==typeof t){t=t instanceof e.constructor?t.valueOf():t;const i=p?.context[0]||null,o=qe(Le(t)),a=Object.assign({},r,{path:h,parent:e});n=new e.constructor(o,i,a),Array.prototype.unshift.call(c,n),e.retroReenableEvents(),"array"===n.type?n.unshift(...t):"object"===n.type&&n[s](t)}else n=t,Array.prototype.unshift.call(c,n);if(u.unshift(n),o){const t=l?[l,".",d].join(""):String(d);if(o.unshiftProp&&e.dispatchEvent(new ye("unshiftProp",{path:t,value:u[d],detail:{elementsIndex:d,element:u[d]}},e)),o["unshiftProp:$index"]){const n=["unshiftProp",":",d].join("");e.dispatchEvent(new ye(n,{path:t,value:u[d],detail:{elementsIndex:d,element:u[d]}},e))}}d++}return o&&o.unshift&&e.dispatchEvent(new ye("unshift",{path:l,detail:{elements:u}},e)),c.length}};const{regularExpressions:Ce}=A;const{recursiveAssign:ze}=A;const{recursiveAssign:Ne,regularExpressions:Re,typeOf:Be}=A;const{recursiveAssign:Ke}=A;const{regularExpressions:Me}=A;const{recursiveAssign:Fe}=A;var Ue={get:function(e,t,...n){let r;const s=t;return"string"==typeof n[0]?(2===n.length&&ze(s,n[1]),r=function(e,t,n){const{target:r,path:s}=e,{mutatorEvents:i,pathkey:o,subpathError:a}=t;if(!0===o){const o=n.split(new RegExp(Ce.quotationEscape)),c=o.shift();let l=r[c];if(o.length){if(!1===a&&void 0===l)return;return l.get(o.join("."),t)}if(i&&(i.getProperty&&e.dispatchEvent(new ye("getProperty",{path:s,value:l,detail:{key:c,value:l}},e)),i["getProperty:$key"])){const t=["getProperty",c].join(":"),n=[s,c].join(".");e.dispatchEvent(new ye(t,{path:n,detail:{value:l}},e))}return l}if(!1===o)return r[propertyKey]}(e,s,...n)):(1===n.length&&ze(s,n[0]),r=function(e,t){const{path:n}=e,{mutatorEvents:r}=t;return r&&r.get&&e.dispatchEvent(new ye("get",{path:n,value:e.valueOf(),detail:{value:e.valueOf()}},e)),e}(e,s,...n)),r},set:function(e,t,...n){let r;const s=t;return"string"==typeof n[0]?(3===n.length&&Ke(s,n[2]),r=function(e,t,n,r){const s=Object.assign({},t),i="set",o=s.assignArray||"set",{target:a,path:c,schema:l}=e,{enableValidation:p,mutatorEvents:u,pathkey:d,recursive:h,source:f,subpathError:v,validationEvents:g}=s;if(!0===d){const t=n.split(new RegExp(Re.quotationEscape)),d=t.shift();let y;const b=Be(r),j=c?[c,d].join("."):String(d);if(t.length){if(h&&void 0===a[d]){let t,n;t="array"===l?.type?l.context[0]:"object"===l?.type?l.context[d]:void 0,n="array"===b?[]:"object"===b||isNaN(Number(d))?{}:[];const r=Ne({},s,{path:j,parent:e});y=new e.constructor(n,t,r)}else y=a[d];if(!1===v&&void 0===y)return;return"array"===y.type?["push","unshift"].includes(o)?y[o](...r):y[o](r):"object"===y.type&&y[i](t.join("."),r,s),y}if(l&&p){const t=l.validateProperty(d,r,f,e);if(g){let n,r;t.valid?(n="validProperty",r=["validProperty",":",d].join("")):(n="nonvalidProperty",r=["nonvalidProperty",":",d].join(""));for(const s of[n,r])e.dispatchEvent(new je(s,t,e))}if(!t.valid)return}if(r&&"object"==typeof r){r instanceof e.constructor&&(r=r.valueOf());const t=Be(r);let n,c;n="array"===l?.type?l.context[0]:"object"===l?.type?l.context[d]:void 0,c="array"===t?[]:"object"===t||isNaN(Number(d))?{}:[];const p=Ne({},s,{path:j,parent:e});y=new e.constructor(c,n,p),a[d]=y,e.retroReenableEvents(),"array"===y.type?["push","unshift"].includes(o)?y[o](...r):y[o](r):"object"===y.type&&y[i](r)}else y=r,a[d]=y;if(u){const t=c?[c,d].join("."):String(d);if(u.setProperty&&e.dispatchEvent(new ye("setProperty",{path:t,value:y,detail:{key:d,value:y}},e)),u["setProperty:$key"]){const n=["setProperty",":",d].join("");e.dispatchEvent(new ye(n,{path:t,value:y,detail:{value:y}},e))}}return y}if(!1===d){let t=n;if(r&&"object"==typeof r){r instanceof e.constructor&&(r=r.valueOf());const n=Be(r);let p,u;"array"===l?.type&&(p=l.context[0]),p="object"===l?.type?l.context[t]:void 0,u="array"===n?[]:"object"===n||isNaN(Number(t))?{}:[];const d=c?[c,t].join("."):String(t),h=Ne({},s,{path:d,parent:e});propertyValue=new e.constructor(u,p,h),a[t]=propertyValue,e.retroReenableEvents(),"array"===propertyValue.type?["push","unshift"].includes(o)?propertyValue[o](...r):propertyValue[o](r):"object"===propertyValue.type&&propertyValue[i](r)}else propertyValue=r,a[t]=propertyValue;if(u){const n=c?[c,t].join("."):String(t);if(u.setProperty&&e.dispatchEvent(new ye("setProperty",{path:n,value:propertyValue,detail:{key:t,value:propertyValue}},e)),u["setProperty:$key"]){const r=["setProperty",":",t].join("");e.dispatchEvent(new ye(r,{path:n,value:propertyValue,detail:{value:propertyValue}},e))}}return propertyValue}}(e,s,...n)):(2===n.length&&Ke(s,n[1]),r=function(e,t,n){for(const[r,s]of Object.entries(n))e.set(r,s,t);const{path:r}=e,{mutatorEvents:s}=t;return s&&s.set&&e.dispatchEvent(new ye("set",{path:r,value:e.valueOf(),detail:{value:e.valueOf()}},e)),e}(e,s,...n)),r},delete:function(e,t,...n){let r;const s=t;return"string"==typeof n[0]?(2===n.length&&Fe(s,n[1]),r=function(e,t,n){const{target:r,path:s,schema:i}=e,{mutatorEvents:o,pathkey:a,subpathError:c,enableValidation:l,validationEvents:p}=t;if(!0!==a)if(!1!==a);else{const a=n,c=r[a];if(i&&l){const t=e.valueOf();delete t[a];const n=i.validate(a,t,e,e);if(p){let t,r;n.valid?(t="validProperty",r=["validProperty",a].join(":")):(t="nonvalidProperty",r=["nonvalidProperty",a].join(":"));for(const s of[t,r])e.dispatchEvent(new ValidatorEvent(s,n,e))}if(!n.valid)return}if(c instanceof e.constructor&&c.delete(t),delete r[a],o&&(o.deleteProperty&&e.dispatchEvent(new ye("deleteProperty",{path:s,value:c,detail:{key:a,value:c}},e)),o["deleteProperty:$key"])){const t=["deleteProperty",a].join(":"),n=[s,a].join(".");e.dispatchEvent(new ye(t,{path:n,value:c,detail:{value:c}},e))}}else{const a=n.split(new RegExp(Me.quotationEscape)),u=a.shift();let d=r[u];if(a.length){if(!1===c&&void 0===d)return;return d.delete(a.join("."),t)}if(i&&l){const t=e.valueOf();delete t[u];const n=i.validate(u,t,{},e);if(p){let t,r;const i=s?[s,u].join("."):String(u);n.valid?(t="validProperty",r=["validProperty",u].join(":")):(t="nonvalidProperty",r=["nonvalidProperty",u].join(":"));for(const s of[t,r])e.dispatchEvent(new ValidatorEvent(s,Object.assign(n,{path:i}),e))}if(!n.valid)return}if(d&&"object"==typeof d&&d.delete(t),delete r[u],o&&(o.deleteProperty&&e.dispatchEvent(new ye("deleteProperty",{path:s,value:d,detail:{key:u,value:d}},e)),o["deleteProperty:$key"])){const t=["deleteProperty",u].join(":"),n=[s,u].join(".");e.dispatchEvent(new ye(t,{path:n,value:d,detail:{value:d}},e))}}}(e,s,...n)):(1===n.length&&Fe(s,n[0]),r=function(e,t){const{target:n}=e;for(const[r,s]of Object.entries(n))e.delete(r,t);const{path:r}=e,{mutatorEvents:s}=t;return s&&s.delete&&e.dispatchEvent(new ye("delete",{path:r,detail:{value:e.valueOf()}},e)),e}(e,s,...n)),r}};const{recursiveAssign:We,recursiveFreeze:He}=A,Je=Object.freeze({object:[{keys:["valueOf"],methodDescriptor:function(e,t){return{value:function(){return t.parse({type:"object"})}}}},{keys:["toString"],methodDescriptor:function(e,t){return{value:function(e={}){const n=void 0!==e.replacer?e.replacer:null,r=void 0!==e.space?e.space:0;return t.parse({type:"string",replacer:n,space:r})}}}},{keys:["entries","fromEntries","getOwnPropertyDescriptors","getOwnPropertyDescriptor","getOwnPropertyNames","groupBy","hasOwn","is","getPrototypeOf","isExtensible","isFrozen","isSealed","keys","preventExtensions","values"],methodDescriptor:function(e,t){return{value:Object[e].bind(null,t.valueOf())}}},{keys:["propertyIsEnumerable","hasOwnProperty"],methodDescriptor:function(e,t){return{value:()=>t.parse({type:"object"})[e]}}},{type:"mutators",keys:Object.keys(ke),methodDescriptor:function(e,t,n){return{value:ke[e].bind(null,t,n)}}}],array:[{keys:["length"],methodDescriptor:function(e,t,n){return{get:()=>t.target.length,set(e){t.target.length=e}}}},{keys:["from","fromAsync","isArray","of"],methodDescriptor:function(e,t){return{value:Array[e]}}},{keys:["at","every","filter","find","findIndex","findLast","findLastIndex","flat","flatMap","forEach","includes","indexOf","join","lastIndexOf","map","reduce","reduceRight","slice","some","sort","toReversed","toSorted","toSpliced","with"],methodDescriptor:function(e,t){return{value:Array.prototype[e].bind(null,t)}}},{type:"mutators",keys:Object.keys(Ie),methodDescriptor:function(e,t,n){return{value:Ie[e].bind(null,t,n)}}}],accessor:[{type:"mutators",keys:Object.keys(Ue),methodDescriptor:function(e,t,n){return{value:Ue[e].bind(null,t,n)}}}]});const{recursiveAssign:Ge,typedObjectLiteral:Qe}=A,Xe=Object.freeze(["push","unshift"]),Ye=Object.freeze(["assign","defineProperties","set"]);const{typedObjectLiteral:Ze,typeOf:et}=A;class tt extends B{static accessors=Object.freeze([(e,t)=>void 0===t?e.target:e.get(t),(e,t)=>void 0===t?e:e[t]]);constructor(e={},t=null,n={}){super({accessors:tt.accessors});const r=e instanceof tt?e.valueOf():e;Object.defineProperty(this,"options",{configurable:!0,get(){const e=(e=>ge({path:null,parent:null,enableValidation:!0,validationEvents:{"validProperty:$key":!0,validProperty:!0,"nonvalidProperty:$key":!0,nonvalidProperty:!0},pathkey:!0,subpathError:!1,assignObject:"set",assignArray:null,methods:{accessor:{get:{mutatorEvents:{get:!0,getProperty:!0,"getProperty:$key":!0}},set:{recursive:!0,mutatorEvents:{set:!0,setProperty:!0,"setProperty:$key":!0}},delete:{mutatorEvents:{delete:!0,deleteProperty:!0,"deleteProperty:$key":!0}}},array:{concat:{mutatorEvents:{"concatValue:$index":!0,concatValue:!0,concat:!0}},copyWithin:{mutatorEvents:{"copyWithinIndex:$index":!0,copyWithinIndex:!0,copyWithin:!0}},fill:{lengthen:!0,mutatorEvents:{"fillIndex:$index":!0,fillIndex:!0,fill:!0}},pop:{mutatorEvents:{pop:!0}},push:{mutatorEvents:{"pushProp:$index":!0,pushProp:!0,push:!0}},reverse:{mutatorEvents:{reverse:!0}},shift:{mutatorEvents:{shift:!0}},splice:{mutatorEvents:{"spliceDelete:$index":!0,spliceDelete:!0,"spliceAdd:$index":!0,spliceAdd:!0,splice:!0}},unshift:{mutatorEvents:{"unshiftProp:$index":!0,unshiftProp:!0,unshift:!0}}},object:{assign:{sourceTree:!0,mutatorEvents:{"assignSourceProperty:$key":!0,assignSourceProperty:!0,assignSource:!0,assign:!0}},defineProperties:{descriptorTree:!0,mutatorEvents:{defineProperties:!0}},defineProperty:{descriptorTree:!0,mutatorEvents:{defineProperty:!0,"defineProperty:$key":!0}},freeze:{recursive:!0,mutatorEvents:{freezeProperty:!0,freeze:!0}},seal:{recursive:!0,mutatorEvents:{sealProperty:!0,seal:!0}}}}},e))(n);if(e.events&&(this.addEvents(e.events),delete e.events),e.enableEvents){const t=typeof e.enableEvents;"boolean"===t?this.enableEvents():"object"===t&&this.enableEvents(e.enableEvents)}return Object.defineProperty(this,"options",{value:e}),e}}),Object.defineProperty(this,"target",{configurable:!0,get(){const e=Ze(r);return Object.defineProperty(this,"target",{value:e}),e}}),Object.defineProperty(this,"type",{configurable:!0,get(){const e=et(this.target);return Object.defineProperty(this,"type",{value:e}),e}}),Object.defineProperty(this,"schema",{configurable:!0,get(){const e=et(t);let n;return["undefined","null"].includes(e)?n=null:t instanceof ve?n=t:"array"===e?n=new ve(...arguments):"object"===e&&(n=new ve(t)),Object.defineProperty(this,"schema",{value:n}),n}}),Object.defineProperty(this,"parent",{configurable:!0,get(){const e=this.options,t=e.parent?e.parent:null;return Object.defineProperty(this,"parent",{value:t}),t}}),Object.defineProperty(this,"path",{configurable:!0,get(){const e=this.options;let t=e.path?String(e.path):null;return Object.defineProperty(this,"path",{value:t}),t}}),Object.defineProperty(this,"key",{configurable:!0,get(){let e=this.path?this.path.split(".").pop():null;return Object.defineProperty(this,"key",{value:e}),e}}),Object.defineProperty(this,"root",{get(){let e=this;e:for(;e&&![void 0,null].includes(e.parent);)e=e.parent;return e}}),function(e){for(const[t,n]of Object.entries(Je))for(const r of n){const{keys:n,methodDescriptor:s,type:i}=r;for(const r of n)if("accessor"===t||"mutators"===i){const n=structuredClone(e.options.methods[t][r]),i=Object.assign({},e.options,n);delete i.mutatorEvents,i.mutatorEvents=n.mutatorEvents,Object.defineProperty(e,r,s(r,e,i))}else Object.defineProperty(e,r,s(r,e))}}(this),function(e,t,n){const{type:r}=e,{assignObject:s,assignArray:i}=n;"array"===r&&Xe.includes(i)?e[i](...t):["array","object"].includes(r)&&Ye.includes(s)&&e[s](t)}(this,r,this.options)}retroReenableEvents(){let e=this;for(;e;)e.reenableEvents({enable:!0}),e=e.parent;return this}parse(e={type:"object",replacer:null,space:0}){let t=Ze(this.type);for(const[e,n]of Object.entries(Object.getOwnPropertyDescriptors(this.target))){let{enumerable:r,value:s,writable:i,configurable:o}=n;s instanceof tt?Object.defineProperty(t,e,{enumerable:r,value:s.valueOf(),writable:i,configurable:o}):Object.defineProperty(t,e,{enumerable:r,value:s,writable:i,configurable:o})}let{type:n,replacer:r,space:s}=e;return"object"===n?t:"string"===n?JSON.stringify(t,r,s):void 0}}export{tt as Model,ve as Schema,de as Validation,U as Validator,K as Verification};
//# sourceMappingURL=objecture.min.js.map
